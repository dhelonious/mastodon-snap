#!/bin/bash

. "$SNAP/snap.env"

update_paths postgres

export PG_PID_FILE="$PID_DIR/postgres.pid"
export PG_HOME="$SNAP_DATA/postgres"
export PG_DATA="$PG_HOME/data"
export PG_CONFIG="$PG_HOME/config"
export PG_SOCK_DIR="$SOCK_DIR/postgres"
export PG_LOG_FILE="$LOG_DIR/postgres.log"
export PG_PORT=5432
export PG_PASSWORD="$(get_secret postgres)"

export HOME="$PG_HOME"
export XDG_CONFIG_HOME="$PG_CONFIG"

get_postgres_version_file() {
    if [ -f "$SNAP_COMMON/pg_version" ]; then
        cat "$SNAP_COMMON/pg_version"
    else
        run_as_daemon_user cat "$PG_DATA/PG_VERSION"
    fi
}

update_postgres_version_file() {
    echo $(run_as_daemon_user cat "$PG_DATA/PG_VERSION") > "$SNAP_COMMON/pg_version"
}

copy_postgres_config() {
    load_postgres_tuning_env
    copy_config_as_daemon_user postgres postgresql.conf
}

enable_postgres_config() {
    run_as_daemon_user sed -i "/^include_if_exists = .*/d" "$PG_DATA/postgresql.conf"
    run_as_daemon_user $SNAP/bin/append "include_if_exists = '$(config_dir postgres)/postgresql.conf'" "$PG_DATA/postgresql.conf"
}

setup_postgres_database() {
    run_as_daemon_user initdb.wrapper
    enable_postgres_config
}

upgrade_postgres_database() {
    PREVIOUS_SNAP_REVISION="$(snapctl get system.previous-revision)"

    # NOTE: This is a fix for older versions and may be removed in the future
    if [ -z "$PREVIOUS_SNAP_REVISION" ]; then
        if is_number "$SNAP_REVISION"; then
            export PREVIOUS_SNAP_VERSION="$(($SNAP_REVISION-1))"
        else
            echo_error "The previous snap revision cannot be determined."
            echo_error "Use 'snap set mastodon-server system.previous-revision=...' to manually set it before retrying the refresh."
            exit 1
        fi
    fi

    run_as_daemon_user pg_upgrade.wrapper "$@" -d "$PG_DATA.old" \
        -b "$(dirname $SNAP)/$PREVIOUS_SNAP_REVISION/postgres/bin"
}

postgres_export_database() {
    postgres_waitready
    $SNAP/bin/pg_dumpall.wrapper -f "$1"
}

postgres_restore_database() {
    postgres_waitready
    $SNAP/bin/psql.wrapper -f "$1" template1 > /dev/null
}

pg_version_changed() {
    PREVIOUS_PG_VERSION="$(get_postgres_version_file)"
    CURRENT_PG_VERSION=$(head -n 1 "$SNAP/postgres/share/postgres.bki" | sed -rn "s/# PostgreSQL ([0-9]+)/\1/p")
    if [ "$CURRENT_PG_VERSION" != "$PREVIOUS_PG_VERSION" ]; then
        return 0
    else
        return 1
    fi
}

postgres_upgrade_waitready() {
    while is_active "postgres-upgrade"; do
        echo "Waiting for postgres-upgrade to finish..."
        sleep 10
    done
}

get_pg_max_connections() {
    local pg_max_connections=$((100 + SYSTEM_RAM / 200 / MB))
    echo $((pg_max_connections > 500 ? 500 : pg_max_connections))
}

# based on pgtune
load_postgres_tuning_env() {
    export PG_SHARED_BUFFERS=$(file_size_unit $((SYSTEM_RAM / 4)))
    export PG_EFFECTIVE_CACHE_SIZE=$(file_size_unit $((SYSTEM_RAM*3 / 4)))
    export PG_MAX_WORKER_PROCESSES=$SYSTEM_CPU
    export PG_MAX_PARALLEL_WORKERS_PER_GATHER=$((SYSTEM_CPU < 2 ? 1 : 2))
    export PG_MAX_PARALLEL_WORKERS=$PG_MAX_WORKER_PROCESSES
    export PG_MAX_PARALLEL_MAINTENANCE_WORKERS=$PG_MAX_PARALLEL_WORKERS_PER_GATHER
    export PG_MAX_CONNECTIONS=$(get_pg_max_connections)
    export PG_WORK_MEM=$(file_size_unit $((SYSTEM_RAM < 8 ? 8*MB : SYSTEM_RAM > 64 ? 64*MB : SYSTEM_RAM * MB)))
    export PG_MAINTENANCE_WORK_MEM=$(file_size_unit $((SYSTEM_RAM > 32*GB ? 2*GB : SYSTEM_RAM / 16)))
    export PG_MAX_WAL_SIZE=$(file_size_unit $((SYSTEM_RAM < 16 ? 2*GB : SYSTEM_RAM > 64 ? 8*GB : SYSTEM_RAM / 8)))

    if [ "$SYSTEM_SSD" == true ]; then
        export PG_RANDOM_PAGE_COST=1.1
        export PG_EFFECTIVE_IO_CONCURRENCY=200
        local vacuum_cost_limit=$((1500 + SYSTEM_CPU * 100))
    else
        export PG_RANDOM_PAGE_COST=4
        export PG_EFFECTIVE_IO_CONCURRENCY=2
        local vacuum_cost_limit=$((800 + SYSTEM_CPU * 50))
    fi

    export PG_VACUUM_COST_LIMIT=$((vacuum_cost_limit < 1000 ? 1000 : vacuum_cost_limit > 4000 ? 4000 : vacuum_cost_limit))
}
