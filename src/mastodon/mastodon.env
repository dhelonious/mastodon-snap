#!/bin/bash

. "$SNAP/snap.env"
. "$SNAP/postgres.env"

update_paths mastodon "$SNAP_DATA"
update_paths ruby
update_paths node
update_paths libvips
update_paths ffmpeg

export MASTODON_DBUSER=mastodon
export MASTODON_DBNAME=mastodon
export MASTODON_DIR="$SNAP_DATA/mastodon"
export MASTODON_USE_LIBVIPS=true

export RUBYLIB="$SNAP/ruby/lib/ruby/3.3.0:$SNAP/ruby/lib/ruby/3.3.0/$SNAP_ARCH"
export BUNDLE_PATH="$MASTODON_DIR/vendor/bundle"
export BUNDLE_GEMFILE="$MASTODON_DIR/Gemfile"
export BUNDLE_RAKEFILE="$MASTODON_DIR/Rakefile"
export GEM_HOME="$MASTODON_DIR/vendor/ruby"
export GEM_PATH="$GEM_HOME"
export YARN_RC_FILENAME="$MASTODON_DIR/.yarnrc.yml"
export YARN_CACHE_FOLDER=/tmp/yarn/cache
export YARN_IGNORE_PATH=1

export UPDATE_BACKUPS="$(snapctl get update.backups)"
export MEDIA_DIR="$(snapctl get media.dir)"
export BACKUP_DIR="$(snapctl get backup.dir)"
export BACKUP_DAYS="$(snapctl get backup.days)"
export CLEANUP_DAYS="$(snapctl get cleanup.days)"
export CLEANUP_MEDIA="$(snapctl get cleanup.media)"
export CLEANUP_HEADERS="$(snapctl get cleanup.headers)"
export CLEANUP_PREVIEWS="$(snapctl get cleanup.previews)"
export CLEANUP_STATUSES="$(snapctl get cleanup.statuses)"
export CLEANUP_ORPHANS="$(snapctl get cleanup.orphans)"
export CLEANUP_ACCOUNTS="$(snapctl get cleanup.accounts)"
export STATUS_MAX_CHARS="$(snapctl get status.char-limit)"
export STATUS_MAX_CHARS_COUNTER="$(snapctl get status.char-counter)"

compose_form="$MASTODON_DIR/app/javascript/mastodon/features/compose/components/compose_form.jsx"
status_length_validator="$MASTODON_DIR/app/validators/status_length_validator.rb"

mastodon_config_exists() {
    if [ -f "$SNAP_COMMON/mastodon.conf" ]; then
        return 0
    else
        return 1
    fi
}

mastodon_get_var() {
    if mastodon_config_exists; then
        sed -rn "s,^.*$1=([^ ]*|'[^']*'|"'"[^"]*"'").*$,\1,p" "$SNAP_COMMON/mastodon.conf"
    fi
}

mastodon_set_var() {
    if mastodon_config_exists; then
        if grep -qF "$1=" "$SNAP_COMMON/mastodon.conf"; then
            $SNAP/bin/sed_inline "s,$1=([^ ]*|'[^']*'|"'"[^"]*"'"),$1=$2," "$SNAP_COMMON/mastodon.conf"
        else
            $SNAP/bin/append "$1=$2" "$SNAP_COMMON/mastodon.conf"
        fi
    else
        echo_error "$SNAP_COMMON/mastodon.conf does not exist."
        exit 1
    fi
}

if mastodon_config_exists; then
    export SECRET_KEY_BASE="$(mastodon_get_var SECRET_KEY_BASE)"
    export OTP_SECRET="$(mastodon_get_var OTP_SECRET)"
    export VAPID_PRIVATE_KEY="$(mastodon_get_var VAPID_PRIVATE_KEY)"
    export VAPID_PUBLIC_KEY="$(mastodon_get_var VAPID_PUBLIC_KEY)"
    export ACTIVE_RECORD_ENCRYPTION_DETERMINISTIC_KEY="$(mastodon_get_var ACTIVE_RECORD_ENCRYPTION_DETERMINISTIC_KEY)"
    export ACTIVE_RECORD_ENCRYPTION_KEY_DERIVATION_SALT="$(mastodon_get_var ACTIVE_RECORD_ENCRYPTION_KEY_DERIVATION_SALT)"
    export ACTIVE_RECORD_ENCRYPTION_PRIMARY_KEY="$(mastodon_get_var ACTIVE_RECORD_ENCRYPTION_PRIMARY_KEY)"
fi

mastodon_rake() {
    cd "$MASTODON_DIR" && run_as_daemon_user bundle exec rake -f "$BUNDLE_RAKEFILE" "$@"
}

mastodon_rails() {
    cd "$MASTODON_DIR" && run_as_daemon_user bundle exec rails "$@"
}

mastodon_node() {
    cd "$MASTODON_DIR" && run_as_daemon_user node "$@"
}

mastodon_yarn() {
    mkdir -p "$YARN_CACHE_FOLDER"
    cd "$MASTODON_DIR" && run_as_daemon_user yarn "$@"
}

mastodon_sidekiq() {
    cd "$MASTODON_DIR" && run_as_daemon_user bundle exec sidekiq "$@"
}

mastodon_tootctl() {
    cd "$MASTODON_DIR" && run_as_daemon_user bundle exec tootctl "$@"
}

check_setup() {
    if ! mastodon_config_exists; then
        echo "Mastodon is not yet set up"
        exit 0
    fi
}

setup_mastodon_database() {
    postgres_waitready
    psql.wrapper -c "create user $MASTODON_DBUSER with password '$PG_PASSWORD';"
    psql.wrapper -c "alter user $MASTODON_DBUSER createdb;"
}

generate_mastodon_vapid_secrets() {
    eval $(mastodon_rails mastodon:webpush:generate_vapid_key)
    export VAPID_PRIVATE_KEY="$VAPID_PRIVATE_KEY"
    export VAPID_PUBLIC_KEY="$VAPID_PUBLIC_KEY"
}

generate_mastodon_db_encryption_secrets() {
    eval $(mastodon_rails db:encryption:init | grep --color=never ACTIVE_RECORD)
    export ACTIVE_RECORD_ENCRYPTION_PRIMARY_KEY="$ACTIVE_RECORD_ENCRYPTION_PRIMARY_KEY"
    export ACTIVE_RECORD_ENCRYPTION_DETERMINISTIC_KEY="$ACTIVE_RECORD_ENCRYPTION_DETERMINISTIC_KEY"
    export ACTIVE_RECORD_ENCRYPTION_KEY_DERIVATION_SALT="$ACTIVE_RECORD_ENCRYPTION_KEY_DERIVATION_SALT"
}

generate_mastodon_secrets() {
    export SECRET_KEY_BASE="$(mastodon_rails secret)"
    export OTP_SECRET="$(mastodon_rails secret)"
    generate_mastodon_vapid_secrets
    generate_mastodon_db_encryption_secrets
}

link_mastodon_config() {
    run_as_daemon_user ln -sfn "$SNAP_COMMON/mastodon.conf" "$MASTODON_DIR/.env.production"
}

copy_mastodon_config() {
    touch_with_permissions root:$DAEMON_USER 664 "$SNAP_COMMON/mastodon.conf" > /dev/null
    envsubst_file "$(cat $SNAP/config/mastodon/mastodon.conf)" "$SNAP_COMMON/mastodon.conf"
    link_mastodon_config
}

update_bundle_path() {
    run_as_daemon_user $SNAP/bin/sed_inline "s|^BUNDLE_PATH: .*$|BUNDLE_PATH: \"$MASTODON_DIR/vendor/bundle\"|" "$MASTODON_DIR/.bundle/config"
}

link_media_dir() {
    if ! [ -d "$MEDIA_DIR" ]; then
        mkdir_with_owner $DAEMON_USER:root "$MEDIA_DIR" || true
    else
        chown $DAEMON_USER:root "$MEDIA_DIR" -R || true
    fi
    run_as_daemon_user ln -sfn "$MEDIA_DIR" "$MASTODON_DIR/public/system"
}

update_mastodon_files() {
    run_as_daemon_user rsync -rl --delete --chown=$DAEMON_USER:root --exclude="\..+.rb\..+" "$SNAP/mastodon" "$SNAP_DATA"
    update_bundle_path
    link_media_dir
}

upgrade_mastodon_config() {
    if mastodon_config_exists; then
        local config="$SNAP/config/mastodon/mastodon.conf"
        local settings=$(
            env -i bash --noprofile --norc -c '
                unset PWD SHLVL;
                set -a;
                source '"$config"';
                set +a;
                for var in $(compgen -e); do
                    echo "$var=${!var}";
                done'
        )
        for setting in $settings; do
            IFS="=" read -r key value <<< "$setting"
            if ! grep -qF "$key=" "$SNAP_COMMON/mastodon.conf"; then
                $SNAP/bin/append "$key=$value" "$SNAP_COMMON/mastodon.conf"
            fi
        done
    fi
}

load_mastodon_env() {
    local config="${1:-$SNAP_COMMON/mastodon.conf}"
    set -a
    source "$config"
    set +a
}

get_backup_dir_file() {
    cat "$SNAP_COMMON/backup.dir"
}

update_backup_dir_file() {
    echo "$BACKUP_DIR" > "$SNAP_COMMON/backup.dir"
}

mastodon_announcement() {
    postgres_waitready
    if ! [ -z $(psql.wrapper -tc "select datname from pg_catalog.pg_database where datname='$MASTODON_DBNAME'") ]; then
        psql.wrapper -d $MASTODON_DBNAME -c "insert into announcements (text, created_at, updated_at, published) values ('$1', now(), now(), '${2:-f}');"
    fi
}

recompile_required() {
    snapctl set recompile-required=true
}

reset_recompile_required() {
    snapctl set recompile-required=false
}

recompile_if_required() {
    if [ "$(snapctl get recompile-required)" == true ]; then
        echo "Recompile assets (this takes some time)"
        $SNAP/bin/recompile
    fi
}

migration_required() {
    snapctl set migration-required=true
}

reset_migration_required() {
    snapctl set migration-required=false
}

pre_migration_required() {
    snapctl set pre-migration-required=true
}

reset_pre_migration_required() {
    snapctl set pre-migration-required=false
}

get_status_max_chars_file() {
    run_as_daemon_user sed -rn "s/^.*MAX_CHARS = ([0-9]+).*$/\1/p" "$status_length_validator"
}

update_status_max_chars() {
    run_as_daemon_user $SNAP/bin/sed_inline "s/length\(fulltext\) > [0-9]+/length(fulltext) > $STATUS_MAX_CHARS/" "$compose_form"
    run_as_daemon_user $SNAP/bin/sed_inline "s/MAX_CHARS = [0-9]+/MAX_CHARS = $STATUS_MAX_CHARS/" "$status_length_validator"
}

check_status_max_chars() {
    while ! is_number "$STATUS_MAX_CHARS"; do
        read -p "Enter a valid number for the status char limit: " STATUS_MAX_CHARS
        snapctl set status.char-limit=$STATUS_MAX_CHARS
        export STATUS_MAX_CHARS="$STATUS_MAX_CHARS"
    done
}

get_status_max_chars_counter_file() {
    run_as_daemon_user sed -rn "s/^.*CharacterCounter max=\{([0-9]+)\}.*$/\1/p" "$compose_form"
}

update_status_max_chars_counter() {
    run_as_daemon_user $SNAP/bin/sed_inline "s/CharacterCounter max=\{[0-9]+\}/CharacterCounter max={$STATUS_MAX_CHARS_COUNTER}/" "$compose_form"
}

check_status_max_chars_counter() {
    while ! is_number "$STATUS_MAX_CHARS_COUNTER"; do
        read -p "Enter a valid number for the status char counter: " STATUS_MAX_CHARS_COUNTER
        snapctl set status.char-limit=$STATUS_MAX_CHARS_COUNTER
        export STATUS_MAX_CHARS_COUNTER="$STATUS_MAX_CHARS_COUNTER"
    done
}
