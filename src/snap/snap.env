#!/bin/bash

if [ -n "${SNAP_ENV:-}" ]; then
    return
fi
SNAP_ENV=1

. "$SNAP/settings.env"

# TODO: Remove old daemon user if no longer required
export OLD_DAEMON_USER=snap_daemon
# TODO: Remove new daemon user if no longer required
export NEW_DAEMON_USER=_daemon_
# TODO: From snapd 2.61 onwards, snap_daemon is being deprecated and replaced with _daemon_ (with underscores), which now possesses a UID of 584792.
export DAEMON_USER="$OLD_DAEMON_USER"
export SNAP_CURRENT="$(dirname $SNAP_DATA)/current"

export HOME="$SNAP_DATA"
export XDG_CONFIG_HOME="$SNAP_DATA"

export KB=1024
export MB=$((1024 * $KB))
export GB=$((1024 * $MB))

export PID_DIR=/tmp/pids
export SOCK_DIR=/tmp/sockets
export LOG_DIR="$SNAP_DATA/logs"
export CERT_DIR="$SNAP_COMMON/certs"
export SECRET_DIR="$SNAP_COMMON/secrets"

export DOMAIN="$(snapctl get domain)"
export EMAIL="$(snapctl get email)"

export SYSTEM_CPU="$(snapctl get system.cpu)"
export SYSTEM_RAM="$(snapctl get system.ram)"
export SYSTEM_SSD="$(snapctl get system.ssd)"

regex_match() {
    if echo "$2" | grep -qE "$1"; then
        return 0
    else
        return 1
    fi
}

is_number() {
    if regex_match '^[0-9]+$' "$1"; then
        return 0
    else
        return 1
    fi
}

is_boolean() {
    if regex_match '^(true|false|yes|no|0|1)$' "$1"; then
        return 0
    else
        return 1
    fi
}

is_hook() {
    if [ "${SNAP_HOOK:-0}" -eq 1 ]; then
        return 0
    else
        return 1
    fi
}

get_total_cpus() {
    local cpus=$(getconf _NPROCESSORS_ONLN)
    if is_number "$cpus"; then
        echo $cpus
    else
        echo 2
    fi
}

get_total_ram() {
    local physPages=$(getconf _PHYS_PAGES)
    local pageSize=$(getconf PAGE_SIZE)
    if is_number "$physPages" && is_number "$pageSize"; then
        echo $((physPages * pageSize))
    else
        echo $((2 * GB))
    fi
}

if [ "$SYSTEM_CPU" == "auto" ]; then
    SYSTEM_CPU=$(get_total_cpus)
    export SYSTEM_CPU=${SYSTEM_CPU:-2}
fi
if [ "$SYSTEM_RAM" == "auto" ]; then
    SYSTEM_RAM=$(get_total_ram)
    export SYSTEM_RAM=${SYSTEM_RAM:-$((2*GB))}
elif is_number "$SYSTEM_RAM"; then
    export SYSTEM_RAM=$(($SYSTEM_RAM * GB))
fi

major_version() {
    echo "$1" | cut -d "." -f1
}

minor_version() {
    echo "$1" | cut -d "." -f1-2
}

get_owner() {
    ls -ld "$1" 2> /dev/null || run_as_daemon_user ls -ld "$1" 2> /dev/null | cut -d " " -f 3
}

get_group() {
    ls -ld "$1" 2> /dev/null || run_as_daemon_user ls -ld "$1" 2> /dev/null | cut -d " " -f 4
}

try_as_daemon_user() {
    run_as_daemon_user "$@" &> /dev/null || "$@"
}

# TODO: Remove if old daemon user no longer required
try_as_old_daemon_user() {
    setpriv --clear-groups --reuid $OLD_DAEMON_USER --regid $OLD_DAEMON_USER \
        -- "$@" &> /dev/null \
    || try_as_daemon_user "$@"
}

mkdir_for_root() {
    for dir in "$@"; do
        if ! [ -d "$dir" ]; then
            echo "Create $dir"
            mkdir -pm 2750 "$dir"
            chown root:$DAEMON_USER "$dir"
        fi
    done
}

mkdir_for_daemon_user() {
    for dir in "$@"; do
        if ! [ -d "$dir" ]; then
            echo "Create $dir"
            try_as_daemon_user mkdir -pm 2770 "$dir"
            try_as_daemon_user chown $DAEMON_USER:root "$dir" || true
        fi
    done
}

mkdir_pid() {
    mkdir -pm 0777 "$PID_DIR"
}

mkdir_sock() {
    mkdir -pm 0777 "$SOCK_DIR"
}

# TODO: Remove if no longer required (after migration from snap_daemon to _daemon_)
fix_for_daemon_user() {
    if ! [ -e "$1" ]; then return; fi

    local owner=$(get_owner "$1")
    local group=$(get_group "$1")
    local wrapper

    if [ "$owner" != "$DAEMON_USER" ] || [ "$group" != "root" ]; then
        case "$owner" in
        root)
            wrapper=()
            ;;
        "$DAEMON_USER")
            wrapper=(try_as_daemon_user)
            ;;
        # TODO: Remove if old daemon user no longer required
        "$OLD_DAEMON_USER")
            wrapper=(try_as_old_daemon_user)
            ;;
        esac

        echo "Trying to fix file ownership and permissions for $1"
        "${wrapper[@]}" find "$1" ! -readable -prune \
            -o \( -type f -exec chmod 660 {} + -exec chown "$DAEMON_USER:root" {} + \) \
            -o \( -type l -exec chown --no-dereference "$DAEMON_USER:root" {} + \) \
            || true

        echo "Trying to fix dir ownership and permissions for $1"
        "${wrapper[@]}" find "$1" ! -readable -prune \
            -o \( -type d -exec chmod 2770 {} + -exec chown "$DAEMON_USER:root" {} + \) \
            || true
    fi
}

echo_error() {
    echo "$@" 1>&2
}

echo_border() {
    local text="$2"
    local text_length=${#text}
    local border=$(printf "$1%.0s" $(seq 1 $((text_length + 4))))

    echo "$border"
    echo "$1 $text $1"
    echo "$border"
}

echo_underline() {
    local text="$2"
    local text_length=${#text}
    local underline=$(printf "$1%.0s" $(seq 1 $((text_length))))

    echo "$text"
    echo "$underline"
}

confirm() {
    read -rp "$1 [y/N] " response
    case "$response" in
        [yY])
            return 0;;
        *)
            return 1;;
    esac
}

check_root() {
    if [ $(id -u) -ne 0 ]; then
        echo_error "This command must be run as root"
        exit 0
    fi
}

is_active() {
    if snapctl services "$SNAP_NAME.$1" | grep -q "inactive"; then
        return 1
    else
        return 0
    fi
}

check_service() {
    if ! is_active "$1"; then
        echo_error "$1 is not running."
        exit 0
    fi
}

update_paths() {
    local bin_path="${2:-$SNAP}"
    local lib_path="${3:-$bin_path}"
    export PATH="$bin_path/$1/bin:$PATH"
    export LD_LIBRARY_PATH="$lib_path/$1/lib:$LD_LIBRARY_PATH"
}

config_dir() {
    echo "$SNAP_DATA/$1/config"
}


get_env_vars() {
    env | sed -rn "s/^([A-Z0-9_]+)=.*$/$\1/p"
}

copy_config() {
    local local_config_dir="$(config_dir $1)"
    if is_hook; then
        echo "Create config dir"
        mkdir -p "$(dirname $local_config_dir/$2)"
    fi
    echo "Copy $2 to $local_config_dir"
    envsubst_file "$(cat $SNAP/config/$1/$2)" "$local_config_dir/$2"
}

copy_config_as_daemon_user() {
    local local_config_dir=$(config_dir $1)
    echo "Copy $2 to $local_config_dir"
    if is_hook; then
        echo "Create config dir"
        mkdir_for_daemon_user "$(dirname $local_config_dir/$2)"
    fi
    run_as_daemon_user envsubst_file "$(cat $SNAP/config/$1/$2)" "$local_config_dir/$2"
    if is_hook; then
        fix_for_daemon_user "$local_config_dir/$2"
    fi
}

config_exists() {
    local local_config_dir="$(config_dir $1)"
    if [ -f "$(config_dir $1)/$2" ]; then
        return 0
    else
        return 1
    fi
}

remove_config() {
    rm -f "$SNAP_DATA/$1/config/$2"
}

remove_config_as_daemon_user() {
    run_as_daemon_user rm -f "$SNAP_DATA/$1/config/$2"
}

get_snap_version_file() {
    cat "$SNAP_COMMON/version"
}

update_snap_version_file() {
    echo "$SNAP_VERSION" > "$SNAP_COMMON/version"
}

snap_version_changed() {
    local snap_version="$(get_snap_version_file)"
    if [ "$SNAP_VERSION" != "$snap_version" ]; then
        return 0
    else
        return 1
    fi
}

secret_exists() {
    if [ -f "$SECRET_DIR/$1" ]; then
        return 0
    else
        return 1
    fi
}

get_secret() {
    if $(secret_exists $1); then
        cat "$SECRET_DIR/$1"
    else
        echo_error "Password for $1 has not yet been generated"
    fi
}

set_secret() {
    echo "$2" > "$SECRET_DIR/$1"
    chmod 640 "$SECRET_DIR/$1"
    chown root:$DAEMON_USER "$SECRET_DIR/$1"
}

generate_secret() {
    if $(secret_exists $1); then
        echo_error "Password for $1 has already been generated"
        local secret=$(get_secret "$1")
    else
        local secret="$(tr -dc _A-Z-a-z-0-9 < /dev/urandom | head -c64)"
        set_secret "$1" "$secret"
    fi

    echo $secret
}

is_domain() {
    if regex_match '^[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$' "$1"; then
        return 0
    else
        return 1
    fi
}

get_domain() {
    while ! is_domain "$DOMAIN"; do
        read -p "Enter a valid domain: " DOMAIN
    done
    snapctl set domain=$DOMAIN
    export DOMAIN="$DOMAIN"
}

is_email() {
    if regex_match '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$' "$1"; then
        return 0
    else
        return 1
    fi
}

get_email() {
    while ! is_email "$EMAIL"; do
        read -p "Enter a valid e-mail address: " EMAIL
    done
    snapctl set email=$EMAIL
    export EMAIL="$EMAIL"
}

check_removable_media() {
    if ! snapctl is-connected removable-media; then
        echo_error "The removable-media plug is not connected;"
        echo_error "Use 'snap connect $SNAP_NAME:removable-media' to enable it"
        exit 0
    fi
}

restart_required() {
    snapctl set services.$1.restart-required=true
}

reset_restart_required() {
    snapctl set services.$1.restart-required=false
}

start_service() {
    case "$1" in
        sidekiq)
            echo Start service sidekiq-high
            snapctl start "$SNAP_NAME.sidekiq-high"
            echo Start service sidekiq-medium
            snapctl start "$SNAP_NAME.sidekiq-medium"
            echo Start service sidekiq-low
            snapctl start "$SNAP_NAME.sidekiq-low"
            ;;
        *)
            echo Start service $1
            snapctl start "$SNAP_NAME.$1"
            ;;
    esac
}

stop_service() {
    case "$1" in
        sidekiq)
            echo Stop service sidekiq-high
            snapctl stop "$SNAP_NAME.sidekiq-high"
            echo Stop service sidekiq-medium
            snapctl stop "$SNAP_NAME.sidekiq-medium"
            echo Stop service sidekiq-low
            snapctl stop "$SNAP_NAME.sidekiq-low"
            ;;
        *)
            echo Stop service $1
            snapctl stop "$SNAP_NAME.$1"
            ;;
    esac
}

restart_service() {
    case "$1" in
        sidekiq)
            echo Restart service sidekiq-high
            snapctl restart "$SNAP_NAME.sidekiq-high"
            echo Restart service sidekiq-medium
            snapctl restart "$SNAP_NAME.sidekiq-medium"
            echo Restart service sidekiq-low
            snapctl restart "$SNAP_NAME.sidekiq-low"
            ;;
        *)
            echo Restart service $1
            snapctl restart "$SNAP_NAME.$1"
            ;;
    esac
}

restart_service_if_required() {
    if [ "$(snapctl get services.$1.restart-required)" == true ]; then
        restart_service $1
        reset_restart_required $1
    fi
}

confirm() {
    read -rp "$1 [y/N] " response
    case "$response" in
        [yY])
            true;;
        *)
            false;;
    esac
}

binary_round() {
    value=$1
    multiplier=1
    while [ $value -gt 16 ]; do
        value=$((value / 2))
        multiplier=$((multiplier * 2))
    done
    echo $((multiplier * value))
}

file_size_unit() {
    local value=$(($(binary_round $1)))
    local unit=""

    if [ $value -ge 10240 ]; then
        unit="kB"
        value=$((value / 1024))
    fi
    if [ $value -ge 10240 ]; then
        unit="MB"
        value=$((value / 1024))
    fi
    if [ $value -ge 10240 ]; then
        unit="GB"
        value=$((value / 1024))
    fi

    echo "$value$unit"
}

begin_print_env() {
    export before_env=$(declare -xp | sed -E "s/^declare -x ([^=]+)=.*/\\1/")
}

end_print_env() {
    declare -xp | sed -E "s/^declare -x //" | grep -vFf <(echo "$before_env")
    unset before_env
}
